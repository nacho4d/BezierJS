<!DOCTYPE HTML>
<html>
  <head>
    <style>
      body { margin: 0px; padding: 30px; font-family:"Lucida Console", sans-serif; }
      form [disabled] { border:none; }
      /*#myCanvas { border: 1px solid #9C9898; }*/
    </style>
    <script>

      squareSide = 45; // side of square in pixels
      unit = 3; // number of squares in a unit
      gridSize = {'w':squareSide*10, 'h':squareSide*10}; // size of grid in pixels

      // Points : Start, control point 1, control point 2 and End
      pts = [{'x':convX(0.0), 'y':convY(0.0)}, {'x':convX(1.3), 'y':convY(-0.05)}, {'x':convX(0.92), 'y':convY(0.2)}, {'x':convX(1.0), 'y':convY(1.0)}];

      radius = 2;
      ptIdx = -1;

      timingFunction = true;

      // Helpers : Conversion functions
      // x_ and y_ are in visible coordinates aprox. (-1,-1).
      // x and y are in canvas coordinates (0, gridFrame.w)
      function convX(x) { return x*squareSide*unit + gridSize.w/2; }
      function convY(y) { return -y*squareSide*unit + gridSize.h/2; }
      function visX(x_) { return (x_ - gridSize.w/2)/(squareSide*unit); }
      function visY(y_) { return -(y_ - gridSize.h/2)/(squareSide*unit); }

      // Helper : Draws a grid within the given rectangle
      function drawGrid(context, squareSide, gridFrame, bordered) {
        //Draw vertical lines
        for (var i = squareSide; i < gridFrame.w; i += squareSide) {
          context.moveTo(gridFrame.x + i, gridFrame.y);
          context.lineTo(gridFrame.x + i, gridFrame.y + gridFrame.h);
          context.stroke();
        }
        if (bordered==true) {
          context.moveTo(gridFrame.x, gridFrame.y);
          context.lineTo(gridFrame.x + gridFrame.w, gridFrame.y);
          context.stroke();
          context.moveTo(gridFrame.x + gridFrame.w, gridFrame.y);
          context.lineTo(gridFrame.x + gridFrame.w, gridFrame.y + gridFrame.h);
          context.stroke();
        }
        // Draw horizontal lines
        for (var j = squareSide; j < gridFrame.h; j += squareSide) {
          context.moveTo(gridFrame.x, gridFrame.y + j);
          context.lineTo(gridFrame.x + gridFrame.w, gridFrame.y + j);
          context.stroke();
        }
        if (bordered==true) {
          context.moveTo(gridFrame.x, gridFrame.y);
          context.lineTo(gridFrame.x, gridFrame.y + gridFrame.h);
          context.stroke();      
          context.moveTo(gridFrame.x, gridFrame.y + gridFrame.h);
          context.lineTo(gridFrame.x + gridFrame.w, gridFrame.y + gridFrame.h);
          context.stroke();
        }
      }

      // Helper : Draws the control points and joint lines
      function drawControlPoints(context) {

        context.save();
        context.beginPath();
        context.strokeStyle = "blue";
        context.lineWidth = 1;
        context.arc(pts[0].x, pts[0].y, radius, 0, 2 * Math.PI, false);
        context.stroke();
        context.arc(pts[1].x, pts[1].y, radius, 0, 2 * Math.PI, false);
        context.stroke();
        context.arc(pts[2].x, pts[2].y, radius, 0, 2 * Math.PI, false);
        context.stroke();
        context.arc(pts[3].x, pts[3].y, radius, 0, 2 * Math.PI, false);
        context.stroke();
        context.restore();
      }

      // Draws the whole canvas
      function drawCanvas() {
        var canvas = document.getElementById("theCanvas");
        var context = canvas.getContext("2d");
        
        var gridFrame = {'x':0, 'y':0, 'w':gridSize.w, 'h':gridSize.h};
        context.clearRect(gridFrame.x, gridFrame.y, gridFrame.w, gridFrame.h);

        // Grid
        context.save();
        context.lineWidth = 1.0;
      
        // Draw dense grid
        context.strokeStyle = "EEEEEE";
        context.beginPath();
        drawGrid(context, squareSide, gridFrame, true);
        context.closePath();
      
        // Draw non-dense grid
        context.strokeStyle = "AAAAAA";
        context.beginPath();
        var gX = (gridSize.w/2) - Math.ceil((gridSize.w/2)/(squareSide*unit))*(squareSide*unit);
        var gY = (gridSize.h/2) - Math.ceil((gridSize.h/2)/(squareSide*unit))*(squareSide*unit);
        var gW = gridSize.w + 2*(-gX);
        var gH = gridSize.h + 2*(-gY);
        drawGrid(context, squareSide*unit, {'x':gX, 'y':gY, 'w':gW, 'h':gH}, false);
        context.closePath();
      
        context.restore();
      
        // Draw control points
        drawControlPoints(context);
      
        // Draw bezier
        context.beginPath();
        context.moveTo(pts[0].x, pts[0].y);
        context.bezierCurveTo(pts[1].x, pts[1].y, pts[2].x, pts[2].y, pts[3].x, pts[3].y);
        context.lineWidth = 2;
        context.strokeStyle = "red";
        context.stroke();
        context.closePath();
      }
      
      // Update coordinates from view
      function updateFields() {
        var form = document.theForm;
        form.pt0x.value = visX(pts[0].x); form.pt0y.value = visY(pts[0].y);
        form.pt1x.value = visX(pts[1].x); form.pt1y.value = visY(pts[1].y);
        form.pt2x.value = visX(pts[2].x); form.pt2y.value = visY(pts[2].y);
        form.pt3x.value = visX(pts[3].x); form.pt3y.value = visY(pts[3].y);
      }

      // Event handlers:
      function dragOn(event){

        // Clicked position
        var canvas = document.getElementById("theCanvas");
        var clickPos = {'x':event.offsetX?(event.offsetX):event.pageX - canvas.offsetLeft, 'y':event.offsetY?(event.offsetY):event.pageY - canvas.offsetTop};

        // Calculate the clicked point
        for (var i = 0; i < pts.length; i++) {
          var dist = Math.sqrt(Math.pow((pts[i].x - clickPos.x), 2) + Math.pow((pts[i].y - clickPos.y), 2));
          if (dist <= radius*2) {
            ptIdx = i;
            return;
          }
        }
        ptIdx = -1;
      }
      
      function dragOff(event) {
        ptIdx = -1;
        // If is in timing function mode, change back the start and end points if needed
        if (timingFunction && (visX(pts[0].x)!=0 || visY(pts[0].y)!=0 || visX(pts[3].x)!=1 || visY(pts[3].y) !=1 )) {
            pts[0] = {'x':convX(0), 'y':convY(0) };
            pts[3] = {'x':convX(1), 'y':convY(1) };
            drawCanvas();
            updateFields();
        }
      }
      
      function dragPt(event) {
        if (ptIdx < 0) return;
       
        // Update points and re-draw the canvas
        pts[ptIdx] = {
        'x':event.offsetX?(event.offsetX):event.pageX - canvas.offsetLeft, 
        'y':event.offsetY?(event.offsetY):event.pageY - canvas.offsetTop};;
        drawCanvas();
        updateFields();
        if (timingFunction && ptIdx != 0 && ptIds != 3) {
          updateObjc();
        }
      }
      
      function keyDownPt(event, value, idx, xory) {
        //console.log("keycode: " + event.keyCode);
        if (event.keyCode == 13 || event.keyCode == 9) { // ENTER key or TAB key
          var form = document.theForm;
          if (xory == 'x') {
            pts[idx].x = convX(value);
          } else {
            pts[idx].y = convY(value);
          }
          drawCanvas();
          updateObjc();
        }
      }

      function updateObjc() {
        var objc = document.getElementById("objc");
        if ((visX(pts[0].x)!=0 || visY(pts[0].y)!=0 || visX(pts[3].x)!=1 || visY(pts[3].y) !=1 )) {
          objc.innerText = "Error : start and/or end point are not (0,0) (1,1) respectively"
        } else {
          objc.innerText = "[CAMediaTimingFunction functionWithControlPoints:" + 
            visX(pts[1].x) + " :" + visY(pts[1].y) + " :" + visX(pts[2].x) + " :" + visY(pts[2].y) + "];";
        }
      }
      
      function toogleMode() {
        timingFunction = !timingFunction;

        if (timingFunction) {
          pts[0] = {'x':convX(0), 'y':convY(0) };
          pts[3] = {'x':convX(1), 'y':convY(1) };
          
        }

        var form = document.theForm
        form.pt0x.disabled = timingFunction;
        form.pt0y.disabled = timingFunction;
        form.pt3x.disabled = timingFunction;
        form.pt3y.disabled = timingFunction;

        var objc = document.getElementById("objc");
        objc.hidden = !timingFunction;
        /*form.pt0x.hidden = timingFunction;
        form.pt0y.hidden = timingFunction;
        form.pt3x.hidden = timingFunction;
        form.pt3y.hidden = timingFunction;
        */
        
        drawCanvas();
        updateFields();
        updateObjc();
        
      }

      window.onload = function() {
        var canvas = document.getElementById("theCanvas");
        canvas.setAttribute("width", gridSize.w);
        canvas.setAttribute("height", gridSize.h);

        // Draw the canvas and update the fields with default values
        drawCanvas();
        updateFields();
        updateObjc();
      };
    </script>
  </head>
  <body>
    <canvas id="theCanvas" onMousedown="dragOn(event)" onmousemove="dragPt(event)" onmouseup="dragOff(event)">
    </canvas>
    <form name="theForm" method="get"> <!-- "post" is OK, but "get" does not show alerts when reloading the form -->
    <input type="checkbox" name="checkbox" onclick="toogleMode()" checked>Bezier path for CAMediaTimingFunction<br>
    <div class="formLine">
    <div id="objc"></div></br>
    </div>
    <div class="formLine">
    Points Info:</br>
    </div>
    <div class="formLine">
    Start Point     ( 
    <input type="text" name="pt0x" size="4" onkeydown="keyDownPt(event, document.theForm.pt0x.value, 0, 'x')"/>,
    <input type="text" name="pt0y" size="4" onkeydown="keyDownPt(event, document.theForm.pt0y.value, 0, 'y')"/> ); </br>
    </div>
    <div class="formLine">
    Control Point 1 ( 
    <input type="text" name="pt1x" size="4" onkeydown="keyDownPt(event, document.theForm.pt1x.value, 1, 'x')"/>,
    <input type="text" name="pt1y" size="4" onkeydown="keyDownPt(event, document.theForm.pt1y.value, 1, 'y')"/> ); </br>
    </div>
    <div class="formLine">
    Control Point 2 ( 
    <input type="text" name="pt2x" size="4" onkeydown="keyDownPt(event, document.theForm.pt2x.value, 2, 'x')"/>,
    <input type="text" name="pt2y" size="4" onkeydown="keyDownPt(event, document.theForm.pt2y.value, 2, 'y')"/> ); </br>
    </div>
    <div class="formLine">
    End Point       ( 
    <input type="text" name="pt3x" size="4" onkeydown="keyDownPt(event, document.theForm.pt3x.value, 3, 'x')"/>,
    <input type="text" name="pt3y" size="4" onkeydown="keyDownPt(event, document.theForm.pt3y.value, 3, 'y')"/> ); </br>
    </div>
    </form>
    </br>
  </body>
</html>